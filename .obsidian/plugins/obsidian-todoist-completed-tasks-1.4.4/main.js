/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TodoistCompletedTasks
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/updateFileContent.ts
var import_obsidian4 = require("obsidian");

// src/fetchTasks.ts
var import_obsidian = require("obsidian");
function generateRawTodoistTask(task, isSubtaskRendering) {
  if (isSubtaskRendering) {
    return {
      taskId: task.item.id,
      parentId: task.item.parent_id,
      content: task.item.content,
      dateCompleted: task.item.completed_at
    };
  } else {
    return {
      taskId: task.task_id,
      parentId: null,
      content: task.content,
      dateCompleted: task.completed_at
    };
  }
}
async function fetchTasks(authToken, timeFrames, renderSubtasks) {
  const {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  } = timeFrames;
  const limit = renderSubtasks ? 30 : 200;
  let mappedResults = [];
  try {
    const url = `https://api.todoist.com/sync/v9/completed/get_all?since=` + timeStartFormattedDate + `T` + timeStartFormattedTime + `&until=` + timeEndFormattedDate + `T` + timeEndFormattedTime + `&limit=${limit}`;
    const completedTasksMetadata = await fetch(url, {
      headers: {
        Authorization: `Bearer ${authToken}`
      }
    }).then(function(response) {
      return response.json();
    });
    if (completedTasksMetadata.items.length === 0) {
      return mappedResults;
    }
    new import_obsidian.Notice(completedTasksMetadata.items.length + " completed tasks found. Processing...");
    if (renderSubtasks) {
      const completedTasksPromises = completedTasksMetadata.items.map(async (task) => {
        return fetchSingleTask(authToken, task.task_id);
      });
      mappedResults = await Promise.all(completedTasksPromises);
      let childTasks = mappedResults.filter((task) => task.parentId !== null);
      let queuedParentTasks = [];
      childTasks.forEach((task) => {
        const parentTask = mappedResults.find((t) => t.taskId === task.parentId);
        if (!parentTask && !queuedParentTasks.includes(task.parentId)) {
          let missedParentTask = fetchSingleTask(authToken, task.parentId);
          mappedResults.push(missedParentTask);
          queuedParentTasks.push(task.parentId);
        }
      });
      mappedResults = await Promise.all(mappedResults);
      mappedResults.forEach((task) => {
        const taskMetadata = completedTasksMetadata.items.find((t) => t.task_id === task.taskId);
        if (!taskMetadata) {
          task.dateCompleted = null;
        } else {
          task.dateCompleted = taskMetadata.completed_at;
        }
      });
    } else {
      mappedResults = completedTasksMetadata.items.map((task) => {
        return generateRawTodoistTask(task, renderSubtasks);
      });
    }
    return mappedResults;
  } catch (e) {
    let errorMsg = "";
    switch (e.httpStatusCode) {
      case void 0:
        errorMsg = `There was a problem pulling data from Todoist. Is your internet connection working?`;
        break;
      case 403:
        errorMsg = "Authentication with todoist server failed. Check that your API token is set correctly in the settings.";
        break;
      default:
        `There was a problem pulling data from Todoist. ${e.responseData}`;
    }
    console.log(errorMsg, e);
    new import_obsidian.Notice(errorMsg);
    throw e;
  }
}
async function fetchSingleTask(authToken, parentId) {
  try {
    const url = `https://api.todoist.com/sync/v9/items/get?item_id=${parentId}`;
    let parentTask = await fetch(url, {
      headers: {
        Authorization: `Bearer ${authToken}`
      }
    });
    const task = await parentTask.json();
    return generateRawTodoistTask(task, true);
  } catch (e) {
    let errorMsg = "";
    switch (e.httpStatusCode) {
      case void 0:
        errorMsg = `There was a problem pulling data from Todoist. Is your internet connection working?`;
        break;
      case 403:
        errorMsg = "Authentication with todoist server failed. Check that your API token is set correctly in the settings.";
        break;
      default:
        `There was a problem pulling data from Todoist. ${e.responseData}`;
    }
    console.log(errorMsg, e);
    new import_obsidian.Notice(errorMsg);
    throw e;
  }
}

// src/formatTasks.ts
var import_obsidian2 = require("obsidian");
function prepareTasksForRendering(tasks) {
  let childTasks = tasks.filter((task) => task.parentId !== null);
  let renderedTasks = [];
  function convertToDateObj(date) {
    if (date === null) {
      return null;
    }
    return new Date(date);
  }
  tasks.forEach((task) => {
    if (task.parentId === null) {
      renderedTasks.push({
        taskId: task.taskId,
        content: task.content,
        dateCompleted: convertToDateObj(task.dateCompleted),
        childTasks: []
      });
    }
  });
  childTasks.forEach(async (task) => {
    const parentTaskIndex = renderedTasks.findIndex((t) => t.taskId === task.parentId);
    renderedTasks[parentTaskIndex].childTasks.push({
      taskId: task.taskId,
      content: task.content,
      dateCompleted: convertToDateObj(task.dateCompleted),
      childTasks: []
    });
  });
  return renderedTasks;
}
function renderTasksAsText(tasks, settings) {
  console.log(tasks);
  function renderTaskFinishDate(task) {
    if (task.dateCompleted === null) {
      return "N/A";
    }
    if (settings.taskPostfix.includes("{task_finish_date}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD");
      ;
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{task_finish_datetime}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD HH:mm");
      ;
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{current_date}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD");
      ;
      return formattedDate;
    }
    if (settings.taskPostfix.includes("{current_datetime}")) {
      const formattedDate = (0, import_obsidian2.moment)(task.dateCompleted).format("YYYY-MM-DD HH:mm");
      ;
      return formattedDate;
    }
  }
  function renderTaskPostfix(task) {
    let regex = /{task_finish_date}|{task_finish_datetime}|{current_date}|{current_datetime}/g;
    return settings.taskPostfix.replace(regex, renderTaskFinishDate(task));
  }
  function renderTaskPrefix(task, index) {
    let regex = /{auto_increment}/g;
    return settings.taskPrefix.replace(regex, `${index + 1}`);
  }
  try {
    let formattedTasks = tasks.reverse().map((t, index) => {
      let formattedParentPrefix = renderTaskPrefix(t, index);
      let formattedParentPostfix = renderTaskPostfix(t);
      let returnString = `${formattedParentPrefix} ${t.content} ${formattedParentPostfix}`;
      if (t.childTasks.length > 0) {
        const childTasks = t.childTasks.reverse().map((childTask, index2) => {
          let formattedChildPrefix = renderTaskPrefix(childTask, index2);
          let formattedPostfix = renderTaskPostfix(childTask);
          return `    ${formattedChildPrefix} ${childTask.content} ${formattedPostfix}`;
        });
        returnString += "\n" + childTasks.join("\n");
      }
      return returnString;
    });
    formattedTasks = formattedTasks.join("\n");
    formattedTasks = `
` + formattedTasks + `
`;
    return formattedTasks;
  } catch (error) {
    console.log(error);
    new import_obsidian2.Notice("There was a problem formatting your tasks. Check the console for more details.", 1e4);
    return "";
  }
}

// src/constants.ts
var CONSTANTS_SEGMENTS = {
  templatedSegmentStart: "%% TCT_TEMPLATED_START 1999-12-01 00:00 %%",
  templatedSegmentEnd: "%% TCT_TEMPLATED_END 2022-04-28 23:59 %%"
};
var CONSTANTS_REGEX = {
  regexStartCompiled: new RegExp(`(${CONSTANTS_SEGMENTS.templatedSegmentStart.slice(0, 22)})+( \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2} )+(${CONSTANTS_SEGMENTS.templatedSegmentStart.slice(0, 2)})`, "g"),
  regexEndCompiled: new RegExp(`(${CONSTANTS_SEGMENTS.templatedSegmentEnd.slice(0, 20)})+( \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2} )+(${CONSTANTS_SEGMENTS.templatedSegmentEnd.slice(0, 2)})`, "g")
};
var FETCH_STRATEGIES = {
  today: "today",
  lastNHours: "lastNHours",
  fromFile: "fromFile"
};

// src/utils.ts
var import_obsidian3 = require("obsidian");
function getTimeframesForUsersToday() {
  let currentTime = new Date();
  currentTime.setHours(0, 0, 0, 0);
  const taskStartInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3 + 24 * 60 * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeframesForLastNHours(hours) {
  let currentTime = new Date();
  const taskStartInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3 - hours * 60 * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime() + currentTime.getTimezoneOffset() * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeframesForLastNHoursWithoutOffset(hours) {
  let currentTime = new Date();
  const taskStartInServerTime = currentTime.getTime() - hours * 60 * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = currentTime.getTime();
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime
  };
}
function getTimeFromKeySegments(fileContent) {
  const startString = fileContent.match(CONSTANTS_REGEX.regexStartCompiled);
  const endString = fileContent.match(CONSTANTS_REGEX.regexEndCompiled);
  let datetimeRegex = /(\d{4}-\d{2}-\d{2} \d{2}:\d{2})/;
  const startDateString = startString[0].match(datetimeRegex);
  const endDateString = endString[0].match(datetimeRegex);
  let currentTimeObj = new Date();
  let startTimeObj = new Date(startDateString[0]);
  let endTimeObj = new Date(endDateString[0]);
  const taskStartInServerTime = startTimeObj.getTime() + currentTimeObj.getTimezoneOffset() * 60 * 1e3;
  const timeStartFormattedDate = (0, import_obsidian3.moment)(taskStartInServerTime).format("YYYY-MM-DD");
  const timeStartFormattedTime = (0, import_obsidian3.moment)(taskStartInServerTime).format("HH:mm");
  const taskEndInServerTime = endTimeObj.getTime() + currentTimeObj.getTimezoneOffset() * 60 * 1e3;
  const timeEndFormattedDate = (0, import_obsidian3.moment)(taskEndInServerTime).format("YYYY-MM-DD");
  const timeEndFormattedTime = (0, import_obsidian3.moment)(taskEndInServerTime).format("HH:mm");
  if (timeStartFormattedDate === "Invalid date" || timeEndFormattedDate === "Invalid date") {
    return null;
  }
  return {
    timeStartFormattedDate,
    timeStartFormattedTime,
    timeEndFormattedDate,
    timeEndFormattedTime,
    startString,
    endString
  };
}
function settingsCheck(settings) {
  if (settings.keywordSegmentStart === "" || settings.keywordSegmentEnd === "") {
    new import_obsidian3.Notice("No keyword segment set. Please set one in the settings.", 1e4);
    return false;
  }
  if (settings.authToken === "") {
    new import_obsidian3.Notice("No auth token set. Please set one in the settings.", 1e4);
    return false;
  }
  return true;
}
function segmentsCheck(fileContent, settings, fetchStrategy) {
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    const startString = fileContent.match(CONSTANTS_REGEX.regexStartCompiled);
    const endString = fileContent.match(CONSTANTS_REGEX.regexEndCompiled);
    if (startString === null || endString === null) {
      new import_obsidian3.Notice(`Keyword segment not found in current file. You are using templated segments. 
Please follow this format: 
${CONSTANTS_SEGMENTS.templatedSegmentStart} 
${CONSTANTS_SEGMENTS.templatedSegmentEnd}`, 1e4);
      return false;
    }
  }
  if (fetchStrategy === FETCH_STRATEGIES.today || fetchStrategy === FETCH_STRATEGIES.lastNHours) {
    if (!fileContent.includes(settings.keywordSegmentStart) || !fileContent.includes(settings.keywordSegmentEnd)) {
      new import_obsidian3.Notice(`Keyword segment not found in current file. Please add: 
'${settings.keywordSegmentStart}' 
and 
'${settings.keywordSegmentEnd}' 
to the file.`, 1e4);
      return false;
    }
  }
  return true;
}

// src/updateFileContent.ts
async function updateFileFromServer(settings, app, time, fetchStrategy) {
  const editor = app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView).editor;
  const fileContent = editor.getValue();
  if (!settingsCheck(settings) || !segmentsCheck(fileContent, settings, fetchStrategy)) {
    return;
  }
  let timeFrames = null;
  if (fetchStrategy === FETCH_STRATEGIES.today) {
    timeFrames = getTimeframesForUsersToday();
  }
  if (fetchStrategy === FETCH_STRATEGIES.lastNHours) {
    timeFrames = getTimeframesForLastNHours(time);
  }
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    timeFrames = getTimeFromKeySegments(fileContent);
  }
  if (timeFrames === null) {
    new import_obsidian4.Notice("Invalid time frame.", 1e4);
    return;
  }
  const rawTasks = await fetchTasks(settings.authToken, timeFrames, settings.renderSubtasks);
  if (rawTasks.length === 0) {
    new import_obsidian4.Notice("No completed tasks found for the given timeframe");
    return;
  }
  let formattedTasks = prepareTasksForRendering(rawTasks);
  let renderedText = renderTasksAsText(formattedTasks, settings);
  let rangeStart = fileContent.indexOf(settings.keywordSegmentStart);
  let rangeEnd = fileContent.indexOf(settings.keywordSegmentEnd);
  if (fetchStrategy === FETCH_STRATEGIES.fromFile) {
    rangeStart = fileContent.indexOf(timeFrames.startString);
    rangeEnd = fileContent.indexOf(timeFrames.endString);
    renderedText = `${timeFrames.startString}${renderedText}`;
  } else {
    renderedText = `${settings.keywordSegmentStart}${renderedText}`;
  }
  editor.replaceRange(renderedText, editor.offsetToPos(rangeStart), editor.offsetToPos(rangeEnd));
  new import_obsidian4.Notice("Completed tasks loaded.");
}

// src/DefaultSettings.ts
var DEFAULT_SETTINGS = {
  settingsVersion: 4,
  keywordSegmentStart: "%% COMPLETED_TODOIST_TASKS_START %%",
  keywordSegmentEnd: "%% COMPLETED_TODOIST_TASKS_END %%",
  authToken: "",
  taskPrefix: "*",
  taskPostfix: "",
  renderSubtasks: true
};

// src/settingsMigrations.ts
function migrateSettings(settings) {
  let newSettings = settings;
  if (getSettingsVersion(newSettings) == 0) {
    newSettings = migrateToV1(settings);
  }
  if (getSettingsVersion(newSettings) == 1) {
    newSettings = migrateToV2(newSettings);
  }
  if (getSettingsVersion(newSettings) == 2) {
    newSettings = migrateToV3(newSettings);
  }
  if (getSettingsVersion(newSettings) == 3) {
    newSettings = migrateToV4(newSettings);
  }
  return newSettings;
}
function getSettingsVersion(settings) {
  var _a;
  return (_a = settings.settingsVersion) != null ? _a : 0;
}
function migrateToV1(settings) {
  return {
    settingsVersion: 1,
    keywordSegmentStart: DEFAULT_SETTINGS.keywordSegmentStart,
    keywordSegmentEnd: DEFAULT_SETTINGS.keywordSegmentEnd,
    authToken: settings.authToken
  };
}
function migrateToV2(settings) {
  return {
    settingsVersion: 2,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: DEFAULT_SETTINGS.taskPrefix
  };
}
function migrateToV3(settings) {
  return {
    settingsVersion: 3,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: settings.taskPrefix,
    renderSubtasks: DEFAULT_SETTINGS.renderSubtasks
  };
}
function migrateToV4(settings) {
  return {
    settingsVersion: 4,
    keywordSegmentStart: settings.keywordSegmentStart,
    keywordSegmentEnd: settings.keywordSegmentEnd,
    authToken: settings.authToken,
    taskPrefix: settings.taskPrefix,
    taskPostfix: DEFAULT_SETTINGS.taskPostfix,
    renderSubtasks: settings.renderSubtasks
  };
}

// src/modal.ts
var import_obsidian5 = require("obsidian");
var ExampleModal = class extends import_obsidian5.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", {
      text: "Fetch completed tasks for last N hours"
    });
    new import_obsidian5.Setting(contentEl).setName("Hours").addText((text) => text.onChange((value) => {
      this.result = value;
    }));
    new import_obsidian5.Setting(contentEl).addButton((btn) => btn.setButtonText("Fetch").setCta().onClick(() => {
      this.close();
      this.onSubmit(this.result);
    }));
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/settingsTabs.ts
var import_obsidian6 = require("obsidian");
var TodoistPluginSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Todoist Completed Tasks" });
    containerEl.createEl("a", {
      text: "重要信息-请参阅使用说明",
      href: "https://github.com/Ledaryy/obsidian-todoist-completed-tasks"
    });
    this.addApiKeySetting(containerEl);
    this.addStartLineDetector(containerEl);
    this.addEndLineDetector(containerEl);
    this.addTaskPrefix(containerEl);
    this.addTaskPostfix(containerEl);
    this.addSubtaskRenderSwitch(containerEl);
  }
  addApiKeySetting(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = '这是您对Todoist的个人身份验证令牌。请注意，拥有此令牌的任何人都可以访问您的所有Todoist数据。它以纯文本形式存储在您的.obsidian/plugins文件夹中。在继续操作之前，请确保您对安全方面的问题感到满意。\n您可以从“API Token”部分获取令牌 ';
      span.createEl("a", null, (link) => {
        link.href = "https://todoist.com/prefs/integrations";
        link.innerText = "here.";
      });
    });
    new import_obsidian6.Setting(containerEl).setName("API 令牌").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.authToken).onChange(async (value) => {
      this.plugin.settings.authToken = value;
      await this.plugin.saveSettings();
    }));
  }
  addStartLineDetector(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "用于检测任务开始的插件的段。\n支持黑曜石的注释语法。";
    });
    new import_obsidian6.Setting(containerEl).setName("开始代码").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.keywordSegmentStart).onChange(async (value) => {
      this.plugin.settings.keywordSegmentStart = value;
      await this.plugin.saveSettings();
    }));
  }
  addEndLineDetector(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "用于检测任务结束的插件的段。\n支持黑曜石的注释语法。";
    });
    new import_obsidian6.Setting(containerEl).setName("结束代码").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.keywordSegmentEnd).onChange(async (value) => {
      this.plugin.settings.keywordSegmentEnd = value;
      await this.plugin.saveSettings();
    }));
  }
  addTaskPrefix(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = '为任务设置前缀。常用用法：\n“*”-项目符号\n“-[x]”-已完成的复选框\n“{AUTO_INCREMENT}”。-理想情况下使用黑碧石标记并将任务和子任务标记为列表\n\n特殊参数“{AUTO_INCREMENT}”将被替换为自动递增编号。\n有关所有其他参数，请参阅 ';
      span.createEl("a", null, (link) => {
        link.href = "https://www.markdownguide.org/tools/obsidian/";
        link.innerText = "Obsidian Markdown";
      });
    });
    new import_obsidian6.Setting(containerEl).setName("前缀").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.taskPrefix).onChange(async (value) => {
      this.plugin.settings.taskPrefix = value;
      await this.plugin.saveSettings();
    }));
  }
  addTaskPostfix(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = '为任务设置后缀。常用用例：\n“\u{1F4AA}”-继续！\n“\u2705{TASK_FINISH_DATE}”-使其与 ';
      span.createEl("a", null, (link) => {
        link.href = "https://github.com/obsidian-tasks-group/obsidian-tasks";
        link.innerText = "Obsidian Tasks";
      });
      span.createEl("p", null, (textSpace) => {
        textSpace.innerText = `特殊参数“{CURRENT_DATE}”将替换为“YYYY-MM-DD”格式的当前日期。

        另一个特殊参数“{TASK_FINISH_DATE}”将替换为“YYYY-MM-DD”格式的任务完成日期。
        
        您还可以使用{TASK_FINISH_DATETIME}和{CURRENT_DATETIME}以“YYYY-MM-DD HH：MM：SS”格式获取日期和时间。
        
        注意：未完成的父任务可以有已完成的子任务，在这种情况下，父任务将使用‘N/A’。`;
      });
    });
    new import_obsidian6.Setting(containerEl).setName("后缀").setDesc(fieldDescription).addText((text) => text.setValue(this.plugin.settings.taskPostfix).onChange(async (value) => {
      this.plugin.settings.taskPostfix = value;
      await this.plugin.saveSettings();
    }));
  }
  addSubtaskRenderSwitch(containerEl) {
    const fieldDescription = document.createDocumentFragment();
    fieldDescription.createEl("span", null, (span) => {
      span.innerText = "如果要加载超过30个(最多200个)任务，则应禁用此选项。这是由于Todoist API的限制。\n如果启用，子任务将呈现为子任务。\n如果禁用，子任务将呈现为普通任务。\n如果启用，则会以递增方式增加加载时间。";
    });
    new import_obsidian6.Setting(containerEl).setName("渲染子任务").setDesc(fieldDescription).addToggle((toggle) => toggle.setValue(this.plugin.settings.renderSubtasks).onChange(async (value) => {
      this.plugin.settings.renderSubtasks = value;
      await this.plugin.saveSettings();
    }));
  }
};

// main.ts
var TodoistCompletedTasks = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("sync", "Fetch today's completed tasks", (evt) => {
      new import_obsidian7.Notice("Fetching completed tasks..");
      updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.today);
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks",
      name: "Fetch today's completed tasks",
      callback: async () => {
        new import_obsidian7.Notice("Fetching completed tasks..");
        updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.today);
      }
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks",
      name: "Fetch completed tasks using dates in segments",
      callback: async () => {
        new import_obsidian7.Notice("Fetching completed tasks..");
        updateFileFromServer(this.settings, this.app, 0, FETCH_STRATEGIES.fromFile);
      }
    });
    this.addCommand({
      id: "todoist-fetch-completed-tasks-for-last-n-hours",
      name: "Fetch completed tasks for last N hours",
      callback: async () => {
        new ExampleModal(this.app, (result) => {
          if (result == null || result == "" || isNaN(Number(result)) || Number(result) < 0) {
            new import_obsidian7.Notice("Please enter a valid number of hours");
            return;
          }
          let times = getTimeframesForLastNHoursWithoutOffset(Number(result));
          const {
            timeStartFormattedDate,
            timeStartFormattedTime,
            timeEndFormattedDate,
            timeEndFormattedTime
          } = times;
          if (this.settings.renderSubtasks) {
            new import_obsidian7.Notice(`You are fetching completed tasks with "Render subtasks" enabled. 
This will limit the number of tasks fetched to 30.
Message will be removed after 30 sec.`, 3e4);
          }
          new import_obsidian7.Notice(`Fetching completed tasks for last ${result} hours.. 
Timerange, from: 
${timeStartFormattedDate} ${timeStartFormattedTime} 
to: 
${timeEndFormattedDate} ${timeEndFormattedTime}. 
Message will be removed after 30 sec.`, 3e4);
          updateFileFromServer(this.settings, this.app, Number(result), FETCH_STRATEGIES.lastNHours);
        }).open();
      }
    });
    this.addSettingTab(new TodoistPluginSettingTab(this.app, this));
  }
  async loadSettings() {
    var _a;
    let storedSettings = (_a = await this.loadData()) != null ? _a : DEFAULT_SETTINGS;
    this.settings = migrateSettings(storedSettings);
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
